// Generated by CoffeeScript 1.9.3
(function() {
  var Slack, api, autoMark, autoReconnect, slack, slackToken;

  Slack = require('slack-client');

  api = require('./routes/api');

  slackToken = process.env.SLACK_TOKEN;

  autoReconnect = true;

  autoMark = true;

  slack = new Slack(slackToken, autoReconnect, autoMark);

  slack.on('open', function() {
    return console.log("Connected to " + slack.team.name + " as " + slack.self.name);
  });

  slack.on('message', function(message) {
    var channel, idx, ref, response, url;
    if ((ref = message.text) != null ? ref.match(/^\<https?:\/\/www.youtube.com/) : void 0) {
      url = message.text.slice(1, -1);
      api.songs.add({
        url: url
      });
      api.songs.fetch({
        complete: function(model, results, valid, invalid) {
          var channel, r, response;
          r = {
            ok: !!valid.length,
            song: results[0]
          };
          response = "Added track " + (r.song.get('title')) + " (" + (api.songs.length - 1) + " already in queue)";
          channel = slack.getChannelGroupOrDMByID(message.channel);
          return channel.send(response);
        }
      });
    }
    if (message.text === "skip") {
      api.songs.shift();
      response = "Skipping to the next track";
      channel = slack.getChannelGroupOrDMByID(message.channel);
      channel.send(response);
    }
    if (message.text === "show queue") {
      idx = 1;
      response = "Queue:\n";
      api.songs.forEach(function(song) {
        response += idx + ": " + (song.get('title')) + "\n";
        return idx += 1;
      });
      channel = slack.getChannelGroupOrDMByID(message.channel);
      return channel.send(response);
    }
  });

  slack.on('error', function(err) {
    return console.error("Error", err);
  });

  slack.login();

  module.exports = slack;

}).call(this);
